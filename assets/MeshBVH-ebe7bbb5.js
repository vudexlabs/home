import{c as zn,a as L,V as Z,P as En,cp as W,cg as tt,aT as $n,s as et,l as Y,B as kn,D as Hn,e as hn}from"./three.module-8f8deecd.js";const vn=0,Xn=1,jn=2,Ys=0,Ks=1,wn=2,Kt=1.25,An=1,_t=6*4+4+4,Zt=65535,Zn=Math.pow(2,-24),Wt=Symbol("SKIP_GENERATION");function Yn(s){return s.index?s.index.count:s.attributes.position.count}function mt(s){return Yn(s)/3}function Kn(s,n=ArrayBuffer){return s>65535?new Uint32Array(new n(4*s)):new Uint16Array(new n(2*s))}function Wn(s,n){if(!s.index){const t=s.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,r=Kn(t,e);s.setIndex(new zn(r,1));for(let l=0;l<t;l++)r[l]=l}}function Vn(s){const n=mt(s),t=s.drawRange,e=t.start/3,r=(t.start+t.count)/3,l=Math.max(0,e),i=Math.min(n,r)-l;return[{offset:Math.floor(l),count:Math.floor(i)}]}function Dn(s){if(!s.groups||!s.groups.length)return Vn(s);const n=[],t=new Set,e=s.drawRange,r=e.start/3,l=(e.start+e.count)/3;for(const c of s.groups){const o=c.start/3,p=(c.start+c.count)/3;t.add(Math.max(r,o)),t.add(Math.min(l,p))}const i=Array.from(t.values()).sort((c,o)=>c-o);for(let c=0;c<i.length-1;c++){const o=i[c],p=i[c+1];n.push({offset:Math.floor(o),count:Math.floor(p-o)})}return n}function Jn(s){if(s.groups.length===0)return!1;const n=mt(s),t=Dn(s).sort((l,i)=>l.offset-i.offset),e=t[t.length-1];e.count=Math.min(n-e.offset,e.count);let r=0;return t.forEach(({count:l})=>r+=l),n!==r}function Jt(s,n,t,e,r){let l=1/0,i=1/0,c=1/0,o=-1/0,p=-1/0,f=-1/0,u=1/0,a=1/0,y=1/0,A=-1/0,B=-1/0,x=-1/0;for(let d=n*6,m=(n+t)*6;d<m;d+=6){const h=s[d+0],T=s[d+1],w=h-T,b=h+T;w<l&&(l=w),b>o&&(o=b),h<u&&(u=h),h>A&&(A=h);const P=s[d+2],_=s[d+3],g=P-_,M=P+_;g<i&&(i=g),M>p&&(p=M),P<a&&(a=P),P>B&&(B=P);const C=s[d+4],S=s[d+5],U=C-S,F=C+S;U<c&&(c=U),F>f&&(f=F),C<y&&(y=C),C>x&&(x=C)}e[0]=l,e[1]=i,e[2]=c,e[3]=o,e[4]=p,e[5]=f,r[0]=u,r[1]=a,r[2]=y,r[3]=A,r[4]=B,r[5]=x}function Qn(s,n=null,t=null,e=null){const r=s.attributes.position,l=s.index?s.index.array:null,i=mt(s),c=r.normalized;let o;n===null?(o=new Float32Array(i*6*4),t=0,e=i):(o=n,t=t||0,e=e||i);const p=r.array,f=r.offset||0;let u=3;r.isInterleavedBufferAttribute&&(u=r.data.stride);const a=["getX","getY","getZ"];for(let y=t;y<t+e;y++){const A=y*3,B=y*6;let x=A+0,d=A+1,m=A+2;l&&(x=l[x],d=l[d],m=l[m]),c||(x=x*u+f,d=d*u+f,m=m*u+f);for(let h=0;h<3;h++){let T,w,b;c?(T=r[a[h]](x),w=r[a[h]](d),b=r[a[h]](m)):(T=p[x+h],w=p[d+h],b=p[m+h]);let P=T;w<P&&(P=w),b<P&&(P=b);let _=T;w>_&&(_=w),b>_&&(_=b);const g=(_-P)/2,M=h*2;o[B+M+0]=P+g,o[B+M+1]=g+(Math.abs(P)+g)*Zn}}return o}function v(s,n,t){return t.min.x=n[s],t.min.y=n[s+1],t.min.z=n[s+2],t.max.x=n[s+3],t.max.y=n[s+4],t.max.z=n[s+5],t}function Tn(s){let n=-1,t=-1/0;for(let e=0;e<3;e++){const r=s[e+3]-s[e];r>t&&(t=r,n=e)}return n}function Bn(s,n){n.set(s)}function Pn(s,n,t){let e,r;for(let l=0;l<3;l++){const i=l+3;e=s[l],r=n[l],t[l]=e<r?e:r,e=s[i],r=n[i],t[i]=e>r?e:r}}function Mt(s,n,t){for(let e=0;e<3;e++){const r=n[s+2*e],l=n[s+2*e+1],i=r-l,c=r+l;i<t[e]&&(t[e]=i),c>t[e+3]&&(t[e+3]=c)}}function wt(s){const n=s[3]-s[0],t=s[4]-s[1],e=s[5]-s[2];return 2*(n*t+t*e+e*n)}const K=32,Gn=(s,n)=>s.candidate-n.candidate,G=new Array(K).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function On(s,n,t,e,r,l){let i=-1,c=0;if(l===vn)i=Tn(n),i!==-1&&(c=(n[i]+n[i+3])/2);else if(l===Xn)i=Tn(s),i!==-1&&(c=ts(t,e,r,i));else if(l===jn){const o=wt(s);let p=Kt*r;const f=e*6,u=(e+r)*6;for(let a=0;a<3;a++){const y=n[a],x=(n[a+3]-y)/K;if(r<K/4){const d=[...G];d.length=r;let m=0;for(let T=f;T<u;T+=6,m++){const w=d[m];w.candidate=t[T+2*a],w.count=0;const{bounds:b,leftCacheBounds:P,rightCacheBounds:_}=w;for(let g=0;g<3;g++)_[g]=1/0,_[g+3]=-1/0,P[g]=1/0,P[g+3]=-1/0,b[g]=1/0,b[g+3]=-1/0;Mt(T,t,b)}d.sort(Gn);let h=r;for(let T=0;T<h;T++){const w=d[T];for(;T+1<h&&d[T+1].candidate===w.candidate;)d.splice(T+1,1),h--}for(let T=f;T<u;T+=6){const w=t[T+2*a];for(let b=0;b<h;b++){const P=d[b];w>=P.candidate?Mt(T,t,P.rightCacheBounds):(Mt(T,t,P.leftCacheBounds),P.count++)}}for(let T=0;T<h;T++){const w=d[T],b=w.count,P=r-w.count,_=w.leftCacheBounds,g=w.rightCacheBounds;let M=0;b!==0&&(M=wt(_)/o);let C=0;P!==0&&(C=wt(g)/o);const S=An+Kt*(M*b+C*P);S<p&&(i=a,p=S,c=w.candidate)}}else{for(let h=0;h<K;h++){const T=G[h];T.count=0,T.candidate=y+x+h*x;const w=T.bounds;for(let b=0;b<3;b++)w[b]=1/0,w[b+3]=-1/0}for(let h=f;h<u;h+=6){let b=~~((t[h+2*a]-y)/x);b>=K&&(b=K-1);const P=G[b];P.count++,Mt(h,t,P.bounds)}const d=G[K-1];Bn(d.bounds,d.rightCacheBounds);for(let h=K-2;h>=0;h--){const T=G[h],w=G[h+1];Pn(T.bounds,w.rightCacheBounds,T.rightCacheBounds)}let m=0;for(let h=0;h<K-1;h++){const T=G[h],w=T.count,b=T.bounds,_=G[h+1].rightCacheBounds;w!==0&&(m===0?Bn(b,Ct):Pn(b,Ct,Ct)),m+=w;let g=0,M=0;m!==0&&(g=wt(Ct)/o);const C=r-m;C!==0&&(M=wt(_)/o);const S=An+Kt*(g*m+M*C);S<p&&(i=a,p=S,c=T.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${l} used.`);return{axis:i,pos:c}}function ts(s,n,t,e){let r=0;for(let l=n,i=n+t;l<i;l++)r+=s[l*6+e*2];return r/t}class Qt{constructor(){this.boundingData=new Float32Array(6)}}function ns(s,n,t,e,r,l){let i=e,c=e+r-1;const o=l.pos,p=l.axis*2;for(;;){for(;i<=c&&t[i*6+p]<o;)i++;for(;i<=c&&t[c*6+p]>=o;)c--;if(i<c){for(let f=0;f<3;f++){let u=n[i*3+f];n[i*3+f]=n[c*3+f],n[c*3+f]=u}for(let f=0;f<6;f++){let u=t[i*6+f];t[i*6+f]=t[c*6+f],t[c*6+f]=u}i++,c--}else return i}}function ss(s,n,t,e,r,l){let i=e,c=e+r-1;const o=l.pos,p=l.axis*2;for(;;){for(;i<=c&&t[i*6+p]<o;)i++;for(;i<=c&&t[c*6+p]>=o;)c--;if(i<c){let f=s[i];s[i]=s[c],s[c]=f;for(let u=0;u<6;u++){let a=t[i*6+u];t[i*6+u]=t[c*6+u],t[c*6+u]=a}i++,c--}else return i}}function R(s,n){return n[s+15]===65535}function I(s,n){return n[s+6]}function q(s,n){return n[s+14]}function $(s){return s+8}function k(s,n){return n[s+6]}function Nn(s,n){return n[s+7]}function Ws(s){return s}let Rn,gt,Xt,In;const es=Math.pow(2,32);function on(s){return"count"in s?1:1+on(s.left)+on(s.right)}function is(s,n,t){return Rn=new Float32Array(t),gt=new Uint32Array(t),Xt=new Uint16Array(t),In=new Uint8Array(t),cn(s,n)}function cn(s,n){const t=s/4,e=s/2,r="count"in n,l=n.boundingData;for(let i=0;i<6;i++)Rn[t+i]=l[i];if(r)if(n.buffer){const i=n.buffer;In.set(new Uint8Array(i),s);for(let c=s,o=s+i.byteLength;c<o;c+=_t){const p=c/2;R(p,Xt)||(gt[c/4+6]+=t)}return s+i.byteLength}else{const i=n.offset,c=n.count;return gt[t+6]=i,Xt[e+14]=c,Xt[e+15]=Zt,s+_t}else{const i=n.left,c=n.right,o=n.splitAxis;let p;if(p=cn(s+_t,i),p/4>es)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return gt[t+6]=p/4,p=cn(p,c),gt[t+7]=o,p}}function rs(s,n){const t=(s.index?s.index.count:s.attributes.position.count)/3,e=t>2**16,r=e?4:2,l=n?new SharedArrayBuffer(t*r):new ArrayBuffer(t*r),i=e?new Uint32Array(l):new Uint16Array(l);for(let c=0,o=i.length;c<o;c++)i[c]=c;return i}function os(s,n,t,e,r){const{maxDepth:l,verbose:i,maxLeafTris:c,strategy:o,onProgress:p,indirect:f}=r,u=s._indirectBuffer,a=s.geometry,y=a.index?a.index.array:null,A=f?ss:ns,B=mt(a),x=new Float32Array(6);let d=!1;const m=new Qt;return Jt(n,t,e,m.boundingData,x),T(m,t,e,x),m;function h(w){p&&p(w/B)}function T(w,b,P,_=null,g=0){if(!d&&g>=l&&(d=!0,i&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(a))),P<=c||g>=l)return h(b+P),w.offset=b,w.count=P,w;const M=On(w.boundingData,_,n,b,P,o);if(M.axis===-1)return h(b+P),w.offset=b,w.count=P,w;const C=A(u,y,n,b,P,M);if(C===b||C===b+P)h(b+P),w.offset=b,w.count=P;else{w.splitAxis=M.axis;const S=new Qt,U=b,F=C-b;w.left=S,Jt(n,U,F,S.boundingData,x),T(S,U,F,x,g+1);const z=new Qt,V=C,Q=P-F;w.right=z,Jt(n,V,Q,z.boundingData,x),T(z,V,Q,x,g+1)}return w}}function cs(s,n){const t=s.geometry;n.indirect&&(s._indirectBuffer=rs(t,n.useSharedArrayBuffer),Jn(t)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),s._indirectBuffer||Wn(t,n);const e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,r=Qn(t),l=n.indirect?Vn(t):Dn(t);s._roots=l.map(i=>{const c=os(s,r,i.offset,i.count,n),o=on(c),p=new e(_t*o);return is(0,c,p),p})}class J{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let e=1/0,r=-1/0;for(let l=0,i=n.length;l<i;l++){const o=n[l][t];e=o<e?o:e,r=o>r?o:r}this.min=e,this.max=r}setFromPoints(n,t){let e=1/0,r=-1/0;for(let l=0,i=t.length;l<i;l++){const c=t[l],o=n.dot(c);e=o<e?o:e,r=o>r?o:r}this.min=e,this.max=r}isSeparated(n){return this.min>n.max||n.min>this.max}}J.prototype.setFromBox=function(){const s=new L;return function(t,e){const r=e.min,l=e.max;let i=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){s.x=r.x*o+l.x*(1-o),s.y=r.y*p+l.y*(1-p),s.z=r.z*f+l.z*(1-f);const u=t.dot(s);i=Math.min(u,i),c=Math.max(u,c)}this.min=i,this.max=c}}();const ls=function(){const s=new L,n=new L,t=new L;return function(r,l,i){const c=r.start,o=s,p=l.start,f=n;t.subVectors(c,p),s.subVectors(r.end,r.start),n.subVectors(l.end,l.start);const u=t.dot(f),a=f.dot(o),y=f.dot(f),A=t.dot(o),x=o.dot(o)*y-a*a;let d,m;x!==0?d=(u*a-A*y)/x:d=0,m=(u+d*a)/y,i.x=d,i.y=m}}(),mn=function(){const s=new Z,n=new L,t=new L;return function(r,l,i,c){ls(r,l,s);let o=s.x,p=s.y;if(o>=0&&o<=1&&p>=0&&p<=1){r.at(o,i),l.at(p,c);return}else if(o>=0&&o<=1){p<0?l.at(0,c):l.at(1,c),r.closestPointToPoint(c,!0,i);return}else if(p>=0&&p<=1){o<0?r.at(0,i):r.at(1,i),l.closestPointToPoint(i,!0,c);return}else{let f;o<0?f=r.start:f=r.end;let u;p<0?u=l.start:u=l.end;const a=n,y=t;if(r.closestPointToPoint(u,!0,n),l.closestPointToPoint(f,!0,t),a.distanceToSquared(u)<=y.distanceToSquared(f)){i.copy(a),c.copy(u);return}else{i.copy(f),c.copy(y);return}}}}(),as=function(){const s=new L,n=new L,t=new En,e=new W;return function(l,i){const{radius:c,center:o}=l,{a:p,b:f,c:u}=i;if(e.start=p,e.end=f,e.closestPointToPoint(o,!0,s).distanceTo(o)<=c||(e.start=p,e.end=u,e.closestPointToPoint(o,!0,s).distanceTo(o)<=c)||(e.start=f,e.end=u,e.closestPointToPoint(o,!0,s).distanceTo(o)<=c))return!0;const B=i.getPlane(t);if(Math.abs(B.distanceToPoint(o))<=c){const d=B.projectPoint(o,n);if(i.containsPoint(d))return!0}return!1}}(),fs=1e-15;function Gt(s){return Math.abs(s)<fs}class j extends tt{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new J),this.points=[this.a,this.b,this.c],this.sphere=new $n,this.plane=new En,this.needsUpdate=!0}intersectsSphere(n){return as(n,this)}update(){const n=this.a,t=this.b,e=this.c,r=this.points,l=this.satAxes,i=this.satBounds,c=l[0],o=i[0];this.getNormal(c),o.setFromPoints(c,r);const p=l[1],f=i[1];p.subVectors(n,t),f.setFromPoints(p,r);const u=l[2],a=i[2];u.subVectors(t,e),a.setFromPoints(u,r);const y=l[3],A=i[3];y.subVectors(e,n),A.setFromPoints(y,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,n),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const s=new L,n=new L,t=new W;return function(r,l=null,i=null){const{start:c,end:o}=r,p=this.points;let f,u=1/0;for(let a=0;a<3;a++){const y=(a+1)%3;t.start.copy(p[a]),t.end.copy(p[y]),mn(t,r,s,n),f=s.distanceToSquared(n),f<u&&(u=f,l&&l.copy(s),i&&i.copy(n))}return this.closestPointToPoint(c,s),f=c.distanceToSquared(s),f<u&&(u=f,l&&l.copy(s),i&&i.copy(c)),this.closestPointToPoint(o,s),f=o.distanceToSquared(s),f<u&&(u=f,l&&l.copy(s),i&&i.copy(o)),Math.sqrt(u)}}();j.prototype.intersectsTriangle=function(){const s=new j,n=new Array(3),t=new Array(3),e=new J,r=new J,l=new L,i=new L,c=new L,o=new L,p=new L,f=new W,u=new W,a=new W,y=new L;function A(B,x,d){const m=B.points;let h=0,T=-1;for(let w=0;w<3;w++){const{start:b,end:P}=f;b.copy(m[w]),P.copy(m[(w+1)%3]),f.delta(i);const _=Gt(x.distanceToPoint(b));if(Gt(x.normal.dot(i))&&_){d.copy(f),h=2;break}const g=x.intersectLine(f,y);if(!g&&_&&y.copy(b),(g||_)&&!Gt(y.distanceTo(P))){if(h<=1)(h===1?d.start:d.end).copy(y),_&&(T=h);else if(h>=2){(T===1?d.start:d.end).copy(y),h=2;break}if(h++,h===2&&T===-1)break}}return h}return function(x,d=null,m=!1){this.needsUpdate&&this.update(),x.isExtendedTriangle?x.needsUpdate&&x.update():(s.copy(x),s.update(),x=s);const h=this.plane,T=x.plane;if(Math.abs(h.normal.dot(T.normal))>1-1e-10){const w=this.satBounds,b=this.satAxes;t[0]=x.a,t[1]=x.b,t[2]=x.c;for(let g=0;g<4;g++){const M=w[g],C=b[g];if(e.setFromPoints(C,t),M.isSeparated(e))return!1}const P=x.satBounds,_=x.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let g=0;g<4;g++){const M=P[g],C=_[g];if(e.setFromPoints(C,n),M.isSeparated(e))return!1}for(let g=0;g<4;g++){const M=b[g];for(let C=0;C<4;C++){const S=_[C];if(l.crossVectors(M,S),e.setFromPoints(l,n),r.setFromPoints(l,t),e.isSeparated(r))return!1}}return d&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=A(this,T,u);if(w===1&&x.containsPoint(u.end))return d&&(d.start.copy(u.end),d.end.copy(u.end)),!0;if(w!==2)return!1;const b=A(x,h,a);if(b===1&&this.containsPoint(a.end))return d&&(d.start.copy(a.end),d.end.copy(a.end)),!0;if(b!==2)return!1;if(u.delta(c),a.delta(o),c.dot(o)<0){let U=a.start;a.start=a.end,a.end=U}const P=u.start.dot(c),_=u.end.dot(c),g=a.start.dot(c),M=a.end.dot(c),C=_<g,S=P<M;return P!==M&&g!==_&&C===S?!1:(d&&(p.subVectors(u.start,a.start),p.dot(c)>0?d.start.copy(u.start):d.start.copy(a.start),p.subVectors(u.end,a.end),p.dot(c)<0?d.end.copy(u.end):d.end.copy(a.end)),!0)}}}();j.prototype.distanceToPoint=function(){const s=new L;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();j.prototype.distanceToTriangle=function(){const s=new L,n=new L,t=["a","b","c"],e=new W,r=new W;return function(i,c=null,o=null){const p=c||o?e:null;if(this.intersectsTriangle(i,p))return(c||o)&&(c&&p.getCenter(c),o&&p.getCenter(o)),0;let f=1/0;for(let u=0;u<3;u++){let a;const y=t[u],A=i[y];this.closestPointToPoint(A,s),a=A.distanceToSquared(s),a<f&&(f=a,c&&c.copy(s),o&&o.copy(A));const B=this[y];i.closestPointToPoint(B,s),a=B.distanceToSquared(s),a<f&&(f=a,c&&c.copy(B),o&&o.copy(s))}for(let u=0;u<3;u++){const a=t[u],y=t[(u+1)%3];e.set(this[a],this[y]);for(let A=0;A<3;A++){const B=t[A],x=t[(A+1)%3];r.set(i[B],i[x]),mn(e,r,s,n);const d=s.distanceToSquared(n);d<f&&(f=d,c&&c.copy(s),o&&o.copy(n))}}return Math.sqrt(f)}}();class N{constructor(n,t,e){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new et,this.invMatrix=new et,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new J),this.alignedSatBounds=new Array(3).fill().map(()=>new J),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}N.prototype.update=function(){return function(){const n=this.matrix,t=this.min,e=this.max,r=this.points;for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const a=1*p|2*f|4*u,y=r[a];y.x=p?e.x:t.x,y.y=f?e.y:t.y,y.z=u?e.z:t.z,y.applyMatrix4(n)}const l=this.satBounds,i=this.satAxes,c=r[0];for(let p=0;p<3;p++){const f=i[p],u=l[p],a=1<<p,y=r[a];f.subVectors(c,y),u.setFromPoints(f,r)}const o=this.alignedSatBounds;o[0].setFromPointsField(r,"x"),o[1].setFromPointsField(r,"y"),o[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();N.prototype.intersectsBox=function(){const s=new J;return function(t){this.needsUpdate&&this.update();const e=t.min,r=t.max,l=this.satBounds,i=this.satAxes,c=this.alignedSatBounds;if(s.min=e.x,s.max=r.x,c[0].isSeparated(s)||(s.min=e.y,s.max=r.y,c[1].isSeparated(s))||(s.min=e.z,s.max=r.z,c[2].isSeparated(s)))return!1;for(let o=0;o<3;o++){const p=i[o],f=l[o];if(s.setFromBox(p,t),f.isSeparated(s))return!1}return!0}}();N.prototype.intersectsTriangle=function(){const s=new j,n=new Array(3),t=new J,e=new J,r=new L;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(s.copy(i),s.update(),i=s);const c=this.satBounds,o=this.satAxes;n[0]=i.a,n[1]=i.b,n[2]=i.c;for(let a=0;a<3;a++){const y=c[a],A=o[a];if(t.setFromPoints(A,n),y.isSeparated(t))return!1}const p=i.satBounds,f=i.satAxes,u=this.points;for(let a=0;a<3;a++){const y=p[a],A=f[a];if(t.setFromPoints(A,u),y.isSeparated(t))return!1}for(let a=0;a<3;a++){const y=o[a];for(let A=0;A<4;A++){const B=f[A];if(r.crossVectors(y,B),t.setFromPoints(r,n),e.setFromPoints(r,u),t.isSeparated(e))return!1}}return!0}}();N.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();N.prototype.distanceToPoint=function(){const s=new L;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();N.prototype.distanceToBox=function(){const s=["x","y","z"],n=new Array(12).fill().map(()=>new W),t=new Array(12).fill().map(()=>new W),e=new L,r=new L;return function(i,c=0,o=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(o||p)&&(i.getCenter(r),this.closestPointToPoint(r,e),i.closestPointToPoint(e,r),o&&o.copy(e),p&&p.copy(r)),0;const f=c*c,u=i.min,a=i.max,y=this.points;let A=1/0;for(let x=0;x<8;x++){const d=y[x];r.copy(d).clamp(u,a);const m=d.distanceToSquared(r);if(m<A&&(A=m,o&&o.copy(d),p&&p.copy(r),m<f))return Math.sqrt(m)}let B=0;for(let x=0;x<3;x++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){const h=(x+1)%3,T=(x+2)%3,w=d<<h|m<<T,b=1<<x|d<<h|m<<T,P=y[w],_=y[b];n[B].set(P,_);const M=s[x],C=s[h],S=s[T],U=t[B],F=U.start,z=U.end;F[M]=u[M],F[C]=d?u[C]:a[C],F[S]=m?u[S]:a[C],z[M]=a[M],z[C]=d?u[C]:a[C],z[S]=m?u[S]:a[C],B++}for(let x=0;x<=1;x++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){r.x=x?a.x:u.x,r.y=d?a.y:u.y,r.z=m?a.z:u.z,this.closestPointToPoint(r,e);const h=r.distanceToSquared(e);if(h<A&&(A=h,o&&o.copy(e),p&&p.copy(r),h<f))return Math.sqrt(h)}for(let x=0;x<12;x++){const d=n[x];for(let m=0;m<12;m++){const h=t[m];mn(d,h,e,r);const T=e.distanceToSquared(r);if(T<A&&(A=T,o&&o.copy(e),p&&p.copy(r),T<f))return Math.sqrt(T)}}return Math.sqrt(A)}}();class xn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class us extends xn{constructor(){super(()=>new j)}}const H=new us;class ps{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const E=new ps;let nt,dt;const it=[],Ut=new xn(()=>new Y);function ys(s,n,t,e,r,l){nt=Ut.getPrimitive(),dt=Ut.getPrimitive(),it.push(nt,dt),E.setBuffer(s._roots[n]);const i=ln(0,s.geometry,t,e,r,l);E.clearBuffer(),Ut.releasePrimitive(nt),Ut.releasePrimitive(dt),it.pop(),it.pop();const c=it.length;return c>0&&(dt=it[c-1],nt=it[c-2]),i}function ln(s,n,t,e,r=null,l=0,i=0){const{float32Array:c,uint16Array:o,uint32Array:p}=E;let f=s*2;if(R(f,o)){const a=I(s,p),y=q(f,o);return v(s,c,nt),e(a,y,!1,i,l+s,nt)}else{let M=function(S){const{uint16Array:U,uint32Array:F}=E;let z=S*2;for(;!R(z,U);)S=$(S),z=S*2;return I(S,F)},C=function(S){const{uint16Array:U,uint32Array:F}=E;let z=S*2;for(;!R(z,U);)S=k(S,F),z=S*2;return I(S,F)+q(z,U)};const a=$(s),y=k(s,p);let A=a,B=y,x,d,m,h;if(r&&(m=nt,h=dt,v(A,c,m),v(B,c,h),x=r(m),d=r(h),d<x)){A=y,B=a;const S=x;x=d,d=S,m=h}m||(m=nt,v(A,c,m));const T=R(A*2,o),w=t(m,T,x,i+1,l+A);let b;if(w===wn){const S=M(A),F=C(A)-S;b=e(S,F,!0,i+1,l+A,m)}else b=w&&ln(A,n,t,e,r,l,i+1);if(b)return!0;h=dt,v(B,c,h);const P=R(B*2,o),_=t(h,P,d,i+1,l+B);let g;if(_===wn){const S=M(B),F=C(B)-S;g=e(S,F,!0,i+1,l+B,h)}else g=_&&ln(B,n,t,e,r,l,i+1);return!!g}}const At=new L,Ot=new L;function ds(s,n,t={},e=0,r=1/0){const l=e*e,i=r*r;let c=1/0,o=null;if(s.shapecast({boundsTraverseOrder:f=>(At.copy(n).clamp(f.min,f.max),At.distanceToSquared(n)),intersectsBounds:(f,u,a)=>a<c&&a<i,intersectsTriangle:(f,u)=>{f.closestPointToPoint(n,At);const a=n.distanceToSquared(At);return a<c&&(Ot.copy(At),c=a,o=u),a<l}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(Ot):t.point=Ot.clone(),t.distance=p,t.faceIndex=o,t}const rt=new L,ot=new L,ct=new L,Lt=new Z,Ft=new Z,zt=new Z,bn=new L,gn=new L,_n=new L,Et=new L;function ms(s,n,t,e,r,l,i,c){let o;if(l===kn?o=s.intersectTriangle(e,t,n,!0,r):o=s.intersectTriangle(n,t,e,l!==Hn,r),o===null)return null;const p=s.origin.distanceTo(r);return p<i||p>c?null:{distance:p,point:r.clone()}}function xs(s,n,t,e,r,l,i,c,o,p,f){rt.fromBufferAttribute(n,l),ot.fromBufferAttribute(n,i),ct.fromBufferAttribute(n,c);const u=ms(s,rt,ot,ct,Et,o,p,f);if(u){e&&(Lt.fromBufferAttribute(e,l),Ft.fromBufferAttribute(e,i),zt.fromBufferAttribute(e,c),u.uv=tt.getInterpolation(Et,rt,ot,ct,Lt,Ft,zt,new Z)),r&&(Lt.fromBufferAttribute(r,l),Ft.fromBufferAttribute(r,i),zt.fromBufferAttribute(r,c),u.uv1=tt.getInterpolation(Et,rt,ot,ct,Lt,Ft,zt,new Z)),t&&(bn.fromBufferAttribute(t,l),gn.fromBufferAttribute(t,i),_n.fromBufferAttribute(t,c),u.normal=tt.getInterpolation(Et,rt,ot,ct,bn,gn,_n,new L),u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1));const a={a:l,b:i,c,normal:new L,materialIndex:0};tt.getNormal(rt,ot,ct,a.normal),u.face=a,u.faceIndex=l}return u}function Yt(s,n,t,e,r,l,i){const c=e*3;let o=c+0,p=c+1,f=c+2;const u=s.index;s.index&&(o=u.getX(o),p=u.getX(p),f=u.getX(f));const{position:a,normal:y,uv:A,uv1:B}=s.attributes,x=xs(t,a,y,A,B,o,p,f,n,l,i);return x?(x.faceIndex=e,r&&r.push(x),x):null}function D(s,n,t,e){const r=s.a,l=s.b,i=s.c;let c=n,o=n+1,p=n+2;t&&(c=t.getX(c),o=t.getX(o),p=t.getX(p)),r.x=e.getX(c),r.y=e.getY(c),r.z=e.getZ(c),l.x=e.getX(o),l.y=e.getY(o),l.z=e.getZ(o),i.x=e.getX(p),i.y=e.getY(p),i.z=e.getZ(p)}const vt=new L,Vt=new L,Dt=new L,Sn=new Z,Mn=new Z,Cn=new Z;function Js(s,n,t,e){const r=n.getIndex().array,l=n.getAttribute("position"),i=n.getAttribute("uv"),c=r[t*3],o=r[t*3+1],p=r[t*3+2];vt.fromBufferAttribute(l,c),Vt.fromBufferAttribute(l,o),Dt.fromBufferAttribute(l,p);let f=0;const u=n.groups,a=t*3;for(let A=0,B=u.length;A<B;A++){const x=u[A],{start:d,count:m}=x;if(a>=d&&a<d+m){f=x.materialIndex;break}}let y=null;return i&&(Sn.fromBufferAttribute(i,c),Mn.fromBufferAttribute(i,o),Cn.fromBufferAttribute(i,p),e&&e.uv?y=e.uv:y=new Z,tt.getInterpolation(s,vt,Vt,Dt,Sn,Mn,Cn,y)),e?(e.face||(e.face={}),e.face.a=c,e.face.b=o,e.face.c=p,e.face.materialIndex=f,e.face.normal||(e.face.normal=new L),tt.getNormal(vt,Vt,Dt,e.face.normal),y&&(e.uv=y),e):{face:{a:c,b:o,c:p,materialIndex:f,normal:tt.getNormal(vt,Vt,Dt,new L)},uv:y}}function hs(s,n,t,e,r,l,i,c){const{geometry:o,_indirectBuffer:p}=s;for(let f=e,u=e+r;f<u;f++)Yt(o,n,t,f,l,i,c)}function ws(s,n,t,e,r,l,i){const{geometry:c,_indirectBuffer:o}=s;let p=1/0,f=null;for(let u=e,a=e+r;u<a;u++){let y;y=Yt(c,n,t,u,null,l,i),y&&y.distance<p&&(f=y,p=y.distance)}return f}function As(s,n,t,e,r,l,i){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let f=s,u=n+s;f<u;f++){let a;if(a=f,D(i,a*3,o,p),i.needsUpdate=!0,e(i,a,r,l))return!0}return!1}function Ts(s,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=s.geometry,e=t.index?t.index.array:null,r=t.attributes.position;let l,i,c,o,p=0;const f=s._roots;for(let a=0,y=f.length;a<y;a++)l=f[a],i=new Uint32Array(l),c=new Uint16Array(l),o=new Float32Array(l),u(0,p),p+=l.byteLength;function u(a,y,A=!1){const B=a*2;if(c[B+15]===Zt){const d=i[a+6],m=c[B+14];let h=1/0,T=1/0,w=1/0,b=-1/0,P=-1/0,_=-1/0;for(let g=3*d,M=3*(d+m);g<M;g++){let C=e[g];const S=r.getX(C),U=r.getY(C),F=r.getZ(C);S<h&&(h=S),S>b&&(b=S),U<T&&(T=U),U>P&&(P=U),F<w&&(w=F),F>_&&(_=F)}return o[a+0]!==h||o[a+1]!==T||o[a+2]!==w||o[a+3]!==b||o[a+4]!==P||o[a+5]!==_?(o[a+0]=h,o[a+1]=T,o[a+2]=w,o[a+3]=b,o[a+4]=P,o[a+5]=_,!0):!1}else{const d=a+8,m=i[a+6],h=d+y,T=m+y;let w=A,b=!1,P=!1;n?w||(b=n.has(h),P=n.has(T),w=!b&&!P):(b=!0,P=!0);const _=w||b,g=w||P;let M=!1;_&&(M=u(d,y,w));let C=!1;g&&(C=u(m,y,w));const S=M||C;if(S)for(let U=0;U<3;U++){const F=d+U,z=m+U,V=o[F],Q=o[F+3],xt=o[z],ht=o[z+3];o[a+U]=V<xt?V:xt,o[a+U+3]=Q>ht?Q:ht}return S}}}function st(s,n,t,e,r){let l,i,c,o,p,f;const u=1/t.direction.x,a=1/t.direction.y,y=1/t.direction.z,A=t.origin.x,B=t.origin.y,x=t.origin.z;let d=n[s],m=n[s+3],h=n[s+1],T=n[s+3+1],w=n[s+2],b=n[s+3+2];return u>=0?(l=(d-A)*u,i=(m-A)*u):(l=(m-A)*u,i=(d-A)*u),a>=0?(c=(h-B)*a,o=(T-B)*a):(c=(T-B)*a,o=(h-B)*a),l>o||c>i||((c>l||isNaN(l))&&(l=c),(o<i||isNaN(i))&&(i=o),y>=0?(p=(w-x)*y,f=(b-x)*y):(p=(b-x)*y,f=(w-x)*y),l>f||p>i)?!1:((p>l||l!==l)&&(l=p),(f<i||i!==i)&&(i=f),l<=r&&i>=e)}function Bs(s,n,t,e,r,l,i,c){const{geometry:o,_indirectBuffer:p}=s;for(let f=e,u=e+r;f<u;f++){let a=p?p[f]:f;Yt(o,n,t,a,l,i,c)}}function Ps(s,n,t,e,r,l,i){const{geometry:c,_indirectBuffer:o}=s;let p=1/0,f=null;for(let u=e,a=e+r;u<a;u++){let y;y=Yt(c,n,t,o?o[u]:u,null,l,i),y&&y.distance<p&&(f=y,p=y.distance)}return f}function bs(s,n,t,e,r,l,i){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let f=s,u=n+s;f<u;f++){let a;if(a=t.resolveTriangleIndex(f),D(i,a*3,o,p),i.needsUpdate=!0,e(i,a,r,l))return!0}return!1}function gs(s,n,t,e,r,l,i){E.setBuffer(s._roots[n]),an(0,s,t,e,r,l,i),E.clearBuffer()}function an(s,n,t,e,r,l,i){const{float32Array:c,uint16Array:o,uint32Array:p}=E,f=s*2;if(R(f,o)){const a=I(s,p),y=q(f,o);hs(n,t,e,a,y,r,l,i)}else{const a=$(s);st(a,c,e,l,i)&&an(a,n,t,e,r,l,i);const y=k(s,p);st(y,c,e,l,i)&&an(y,n,t,e,r,l,i)}}const _s=["x","y","z"];function Ss(s,n,t,e,r,l){E.setBuffer(s._roots[n]);const i=fn(0,s,t,e,r,l);return E.clearBuffer(),i}function fn(s,n,t,e,r,l){const{float32Array:i,uint16Array:c,uint32Array:o}=E;let p=s*2;if(R(p,c)){const u=I(s,o),a=q(p,c);return ws(n,t,e,u,a,r,l)}else{const u=Nn(s,o),a=_s[u],A=e.direction[a]>=0;let B,x;A?(B=$(s),x=k(s,o)):(B=k(s,o),x=$(s));const m=st(B,i,e,r,l)?fn(B,n,t,e,r,l):null;if(m){const w=m.point[a];if(A?w<=i[x+u]:w>=i[x+u+3])return m}const T=st(x,i,e,r,l)?fn(x,n,t,e,r,l):null;return m&&T?m.distance<=T.distance?m:T:m||T||null}}const Nt=new Y,lt=new j,at=new j,Tt=new et,Un=new N,Rt=new N;function Ms(s,n,t,e){E.setBuffer(s._roots[n]);const r=un(0,s,t,e);return E.clearBuffer(),r}function un(s,n,t,e,r=null){const{float32Array:l,uint16Array:i,uint32Array:c}=E;let o=s*2;if(r===null&&(t.boundingBox||t.computeBoundingBox(),Un.set(t.boundingBox.min,t.boundingBox.max,e),r=Un),R(o,i)){const f=n.geometry,u=f.index,a=f.attributes.position,y=t.index,A=t.attributes.position,B=I(s,c),x=q(o,i);if(Tt.copy(e).invert(),t.boundsTree)return v(s,l,Rt),Rt.matrix.copy(Tt),Rt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:m=>Rt.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(e),m.b.applyMatrix4(e),m.c.applyMatrix4(e),m.needsUpdate=!0;for(let h=B*3,T=(x+B)*3;h<T;h+=3)if(D(at,h,u,a),at.needsUpdate=!0,m.intersectsTriangle(at))return!0;return!1}});for(let d=B*3,m=(x+B)*3;d<m;d+=3){D(lt,d,u,a),lt.a.applyMatrix4(Tt),lt.b.applyMatrix4(Tt),lt.c.applyMatrix4(Tt),lt.needsUpdate=!0;for(let h=0,T=y.count;h<T;h+=3)if(D(at,h,y,A),at.needsUpdate=!0,lt.intersectsTriangle(at))return!0}}else{const f=s+8,u=c[s+6];return v(f,l,Nt),!!(r.intersectsBox(Nt)&&un(f,n,t,e,r)||(v(u,l,Nt),r.intersectsBox(Nt)&&un(u,n,t,e,r)))}}const It=new et,tn=new N,Bt=new N,Cs=new L,Us=new L,Ls=new L,Fs=new L;function zs(s,n,t,e={},r={},l=0,i=1/0){n.boundingBox||n.computeBoundingBox(),tn.set(n.boundingBox.min,n.boundingBox.max,t),tn.needsUpdate=!0;const c=s.geometry,o=c.attributes.position,p=c.index,f=n.attributes.position,u=n.index,a=H.getPrimitive(),y=H.getPrimitive();let A=Cs,B=Us,x=null,d=null;r&&(x=Ls,d=Fs);let m=1/0,h=null,T=null;return It.copy(t).invert(),Bt.matrix.copy(It),s.shapecast({boundsTraverseOrder:w=>tn.distanceToBox(w),intersectsBounds:(w,b,P)=>P<m&&P<i?(b&&(Bt.min.copy(w.min),Bt.max.copy(w.max),Bt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:_=>Bt.distanceToBox(_),intersectsBounds:(_,g,M)=>M<m&&M<i,intersectsRange:(_,g)=>{for(let M=_,C=_+g;M<C;M++){D(y,3*M,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let S=w,U=w+b;S<U;S++){D(a,3*S,p,o),a.needsUpdate=!0;const F=a.distanceToTriangle(y,A,x);if(F<m&&(B.copy(A),d&&d.copy(x),m=F,h=S,T=M),F<l)return!0}}}});{const P=mt(n);for(let _=0,g=P;_<g;_++){D(y,3*_,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=w,C=w+b;M<C;M++){D(a,3*M,p,o),a.needsUpdate=!0;const S=a.distanceToTriangle(y,A,x);if(S<m&&(B.copy(A),d&&d.copy(x),m=S,h=M,T=_),S<l)return!0}}}}}),H.releasePrimitive(a),H.releasePrimitive(y),m===1/0?null:(e.point?e.point.copy(B):e.point=B.clone(),e.distance=m,e.faceIndex=h,r&&(r.point?r.point.copy(d):r.point=d.clone(),r.point.applyMatrix4(It),B.applyMatrix4(It),r.distance=B.sub(r.point).length(),r.faceIndex=T),e)}function Es(s,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=s.geometry,e=t.index?t.index.array:null,r=t.attributes.position;let l,i,c,o,p=0;const f=s._roots;for(let a=0,y=f.length;a<y;a++)l=f[a],i=new Uint32Array(l),c=new Uint16Array(l),o=new Float32Array(l),u(0,p),p+=l.byteLength;function u(a,y,A=!1){const B=a*2;if(c[B+15]===Zt){const d=i[a+6],m=c[B+14];let h=1/0,T=1/0,w=1/0,b=-1/0,P=-1/0,_=-1/0;for(let g=d,M=d+m;g<M;g++){const C=3*s.resolveTriangleIndex(g);for(let S=0;S<3;S++){let U=C+S;U=e?e[U]:U;const F=r.getX(U),z=r.getY(U),V=r.getZ(U);F<h&&(h=F),F>b&&(b=F),z<T&&(T=z),z>P&&(P=z),V<w&&(w=V),V>_&&(_=V)}}return o[a+0]!==h||o[a+1]!==T||o[a+2]!==w||o[a+3]!==b||o[a+4]!==P||o[a+5]!==_?(o[a+0]=h,o[a+1]=T,o[a+2]=w,o[a+3]=b,o[a+4]=P,o[a+5]=_,!0):!1}else{const d=a+8,m=i[a+6],h=d+y,T=m+y;let w=A,b=!1,P=!1;n?w||(b=n.has(h),P=n.has(T),w=!b&&!P):(b=!0,P=!0);const _=w||b,g=w||P;let M=!1;_&&(M=u(d,y,w));let C=!1;g&&(C=u(m,y,w));const S=M||C;if(S)for(let U=0;U<3;U++){const F=d+U,z=m+U,V=o[F],Q=o[F+3],xt=o[z],ht=o[z+3];o[a+U]=V<xt?V:xt,o[a+U+3]=Q>ht?Q:ht}return S}}}function vs(s,n,t,e,r,l,i){E.setBuffer(s._roots[n]),pn(0,s,t,e,r,l,i),E.clearBuffer()}function pn(s,n,t,e,r,l,i){const{float32Array:c,uint16Array:o,uint32Array:p}=E,f=s*2;if(R(f,o)){const a=I(s,p),y=q(f,o);Bs(n,t,e,a,y,r,l,i)}else{const a=$(s);st(a,c,e,l,i)&&pn(a,n,t,e,r,l,i);const y=k(s,p);st(y,c,e,l,i)&&pn(y,n,t,e,r,l,i)}}const Vs=["x","y","z"];function Ds(s,n,t,e,r,l){E.setBuffer(s._roots[n]);const i=yn(0,s,t,e,r,l);return E.clearBuffer(),i}function yn(s,n,t,e,r,l){const{float32Array:i,uint16Array:c,uint32Array:o}=E;let p=s*2;if(R(p,c)){const u=I(s,o),a=q(p,c);return Ps(n,t,e,u,a,r,l)}else{const u=Nn(s,o),a=Vs[u],A=e.direction[a]>=0;let B,x;A?(B=$(s),x=k(s,o)):(B=k(s,o),x=$(s));const m=st(B,i,e,r,l)?yn(B,n,t,e,r,l):null;if(m){const w=m.point[a];if(A?w<=i[x+u]:w>=i[x+u+3])return m}const T=st(x,i,e,r,l)?yn(x,n,t,e,r,l):null;return m&&T?m.distance<=T.distance?m:T:m||T||null}}const qt=new Y,ft=new j,ut=new j,Pt=new et,Ln=new N,$t=new N;function Ns(s,n,t,e){E.setBuffer(s._roots[n]);const r=dn(0,s,t,e);return E.clearBuffer(),r}function dn(s,n,t,e,r=null){const{float32Array:l,uint16Array:i,uint32Array:c}=E;let o=s*2;if(r===null&&(t.boundingBox||t.computeBoundingBox(),Ln.set(t.boundingBox.min,t.boundingBox.max,e),r=Ln),R(o,i)){const f=n.geometry,u=f.index,a=f.attributes.position,y=t.index,A=t.attributes.position,B=I(s,c),x=q(o,i);if(Pt.copy(e).invert(),t.boundsTree)return v(s,l,$t),$t.matrix.copy(Pt),$t.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:m=>$t.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(e),m.b.applyMatrix4(e),m.c.applyMatrix4(e),m.needsUpdate=!0;for(let h=B,T=x+B;h<T;h++)if(D(ut,3*n.resolveTriangleIndex(h),u,a),ut.needsUpdate=!0,m.intersectsTriangle(ut))return!0;return!1}});for(let d=B,m=x+B;d<m;d++){const h=n.resolveTriangleIndex(d);D(ft,3*h,u,a),ft.a.applyMatrix4(Pt),ft.b.applyMatrix4(Pt),ft.c.applyMatrix4(Pt),ft.needsUpdate=!0;for(let T=0,w=y.count;T<w;T+=3)if(D(ut,T,y,A),ut.needsUpdate=!0,ft.intersectsTriangle(ut))return!0}}else{const f=s+8,u=c[s+6];return v(f,l,qt),!!(r.intersectsBox(qt)&&dn(f,n,t,e,r)||(v(u,l,qt),r.intersectsBox(qt)&&dn(u,n,t,e,r)))}}const kt=new et,nn=new N,bt=new N,Rs=new L,Is=new L,qs=new L,$s=new L;function ks(s,n,t,e={},r={},l=0,i=1/0){n.boundingBox||n.computeBoundingBox(),nn.set(n.boundingBox.min,n.boundingBox.max,t),nn.needsUpdate=!0;const c=s.geometry,o=c.attributes.position,p=c.index,f=n.attributes.position,u=n.index,a=H.getPrimitive(),y=H.getPrimitive();let A=Rs,B=Is,x=null,d=null;r&&(x=qs,d=$s);let m=1/0,h=null,T=null;return kt.copy(t).invert(),bt.matrix.copy(kt),s.shapecast({boundsTraverseOrder:w=>nn.distanceToBox(w),intersectsBounds:(w,b,P)=>P<m&&P<i?(b&&(bt.min.copy(w.min),bt.max.copy(w.max),bt.needsUpdate=!0),!0):!1,intersectsRange:(w,b)=>{if(n.boundsTree){const P=n.boundsTree;return P.shapecast({boundsTraverseOrder:_=>bt.distanceToBox(_),intersectsBounds:(_,g,M)=>M<m&&M<i,intersectsRange:(_,g)=>{for(let M=_,C=_+g;M<C;M++){const S=P.resolveTriangleIndex(M);D(y,3*S,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let U=w,F=w+b;U<F;U++){const z=s.resolveTriangleIndex(U);D(a,3*z,p,o),a.needsUpdate=!0;const V=a.distanceToTriangle(y,A,x);if(V<m&&(B.copy(A),d&&d.copy(x),m=V,h=U,T=M),V<l)return!0}}}})}else{const P=mt(n);for(let _=0,g=P;_<g;_++){D(y,3*_,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=w,C=w+b;M<C;M++){const S=s.resolveTriangleIndex(M);D(a,3*S,p,o),a.needsUpdate=!0;const U=a.distanceToTriangle(y,A,x);if(U<m&&(B.copy(A),d&&d.copy(x),m=U,h=M,T=_),U<l)return!0}}}}}),H.releasePrimitive(a),H.releasePrimitive(y),m===1/0?null:(e.point?e.point.copy(B):e.point=B.clone(),e.distance=m,e.faceIndex=h,r&&(r.point?r.point.copy(d):r.point=d.clone(),r.point.applyMatrix4(kt),B.applyMatrix4(kt),r.distance=B.sub(r.point).length(),r.faceIndex=T),e)}function Hs(){return typeof SharedArrayBuffer<"u"}const St=new E.constructor,jt=new E.constructor,O=new xn(()=>new Y),pt=new Y,yt=new Y,sn=new Y,en=new Y;let rn=!1;function Xs(s,n,t,e){if(rn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");rn=!0;const r=s._roots,l=n._roots;let i,c=0,o=0;const p=new et().copy(t).invert();for(let f=0,u=r.length;f<u;f++){St.setBuffer(r[f]),o=0;const a=O.getPrimitive();v(0,St.float32Array,a),a.applyMatrix4(p);for(let y=0,A=l.length;y<A&&(jt.setBuffer(l[f]),i=X(0,0,t,p,e,c,o,0,0,a),jt.clearBuffer(),o+=l[y].length,!i);y++);if(O.releasePrimitive(a),St.clearBuffer(),c+=r[f].length,i)break}return rn=!1,i}function X(s,n,t,e,r,l=0,i=0,c=0,o=0,p=null,f=!1){let u,a;f?(u=jt,a=St):(u=St,a=jt);const y=u.float32Array,A=u.uint32Array,B=u.uint16Array,x=a.float32Array,d=a.uint32Array,m=a.uint16Array,h=s*2,T=n*2,w=R(h,B),b=R(T,m);let P=!1;if(b&&w)f?P=r(I(n,d),q(n*2,m),I(s,A),q(s*2,B),o,i+n,c,l+s):P=r(I(s,A),q(s*2,B),I(n,d),q(n*2,m),c,l+s,o,i+n);else if(b){const _=O.getPrimitive();v(n,x,_),_.applyMatrix4(t);const g=$(s),M=k(s,A);v(g,y,pt),v(M,y,yt);const C=_.intersectsBox(pt),S=_.intersectsBox(yt);P=C&&X(n,g,e,t,r,i,l,o,c+1,_,!f)||S&&X(n,M,e,t,r,i,l,o,c+1,_,!f),O.releasePrimitive(_)}else{const _=$(n),g=k(n,d);v(_,x,sn),v(g,x,en);const M=p.intersectsBox(sn),C=p.intersectsBox(en);if(M&&C)P=X(s,_,t,e,r,l,i,c,o+1,p,f)||X(s,g,t,e,r,l,i,c,o+1,p,f);else if(M)if(w)P=X(s,_,t,e,r,l,i,c,o+1,p,f);else{const S=O.getPrimitive();S.copy(sn).applyMatrix4(t);const U=$(s),F=k(s,A);v(U,y,pt),v(F,y,yt);const z=S.intersectsBox(pt),V=S.intersectsBox(yt);P=z&&X(_,U,e,t,r,i,l,o,c+1,S,!f)||V&&X(_,F,e,t,r,i,l,o,c+1,S,!f),O.releasePrimitive(S)}else if(C)if(w)P=X(s,g,t,e,r,l,i,c,o+1,p,f);else{const S=O.getPrimitive();S.copy(en).applyMatrix4(t);const U=$(s),F=k(s,A);v(U,y,pt),v(F,y,yt);const z=S.intersectsBox(pt),V=S.intersectsBox(yt);P=z&&X(g,U,e,t,r,i,l,o,c+1,S,!f)||V&&X(g,F,e,t,r,i,l,o,c+1,S,!f),O.releasePrimitive(S)}}return P}const Ht=new N,Fn=new Y,js={strategy:vn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class qn{static serialize(n,t={}){t={cloneBuffers:!0,...t};const e=n.geometry,r=n._roots,l=n._indirectBuffer,i=e.getIndex();let c;return t.cloneBuffers?c={roots:r.map(o=>o.slice()),index:i?i.array.slice():null,indirectBuffer:l?l.slice():null}:c={roots:r,index:i?i.array:null,indirectBuffer:l},c}static deserialize(n,t,e={}){e={setIndex:!0,indirect:!!n.indirectBuffer,...e};const{index:r,roots:l,indirectBuffer:i}=n,c=new qn(t,{...e,[Wt]:!0});if(c._roots=l,c._indirectBuffer=i||null,e.setIndex){const o=t.getIndex();if(o===null){const p=new zn(n.index,1,!1);t.setIndex(p)}else o.array!==r&&(o.array.set(r),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...js,[Wt]:!1},t),t.useSharedArrayBuffer&&!Hs())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Wt]||(cs(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new Y))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(n=null){return(this.indirect?Es:Ts)(this,n)}traverse(n,t=0){const e=this._roots[t],r=new Uint32Array(e),l=new Uint16Array(e);i(0);function i(c,o=0){const p=c*2,f=l[p+15]===Zt;if(f){const u=r[c+6],a=l[p+14];n(o,f,new Float32Array(e,c*4,6),u,a)}else{const u=c+_t/4,a=r[c+6],y=r[c+7];n(o,f,new Float32Array(e,c*4,6),y)||(i(u,o+1),i(a,o+1))}}}raycast(n,t=hn,e=0,r=1/0){const l=this._roots,i=this.geometry,c=[],o=t.isMaterial,p=Array.isArray(t),f=i.groups,u=o?t.side:t,a=this.indirect?vs:gs;for(let y=0,A=l.length;y<A;y++){const B=p?t[f[y].materialIndex].side:u,x=c.length;if(a(this,y,B,n,c,e,r),p){const d=f[y].materialIndex;for(let m=x,h=c.length;m<h;m++)c[m].face.materialIndex=d}}return c}raycastFirst(n,t=hn,e=0,r=1/0){const l=this._roots,i=this.geometry,c=t.isMaterial,o=Array.isArray(t);let p=null;const f=i.groups,u=c?t.side:t,a=this.indirect?Ds:Ss;for(let y=0,A=l.length;y<A;y++){const B=o?t[f[y].materialIndex].side:u,x=a(this,y,B,n,e,r);x!=null&&(p==null||x.distance<p.distance)&&(p=x,o&&(x.face.materialIndex=f[y].materialIndex))}return p}intersectsGeometry(n,t){let e=!1;const r=this._roots,l=this.indirect?Ns:Ms;for(let i=0,c=r.length;i<c&&(e=l(this,i,n,t),!e);i++);return e}shapecast(n){const t=H.getPrimitive(),e=this.indirect?bs:As;let{boundsTraverseOrder:r,intersectsBounds:l,intersectsRange:i,intersectsTriangle:c}=n;if(i&&c){const u=i;i=(a,y,A,B,x)=>u(a,y,A,B,x)?!0:e(a,y,this,c,A,B,t)}else i||(c?i=(u,a,y,A)=>e(u,a,this,c,y,A,t):i=(u,a,y)=>y);let o=!1,p=0;const f=this._roots;for(let u=0,a=f.length;u<a;u++){const y=f[u];if(o=ys(this,u,l,i,r,p),o)break;p+=y.byteLength}return H.releasePrimitive(t),o}bvhcast(n,t,e){let{intersectsRanges:r,intersectsTriangles:l}=e;const i=H.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,p=this.indirect?A=>{const B=this.resolveTriangleIndex(A);D(i,B*3,c,o)}:A=>{D(i,A*3,c,o)},f=H.getPrimitive(),u=n.geometry.index,a=n.geometry.attributes.position,y=n.indirect?A=>{const B=n.resolveTriangleIndex(A);D(f,B*3,u,a)}:A=>{D(f,A*3,u,a)};if(l){const A=(B,x,d,m,h,T,w,b)=>{for(let P=d,_=d+m;P<_;P++){y(P),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let g=B,M=B+x;g<M;g++)if(p(g),i.needsUpdate=!0,l(i,f,g,P,h,T,w,b))return!0}return!1};if(r){const B=r;r=function(x,d,m,h,T,w,b,P){return B(x,d,m,h,T,w,b,P)?!0:A(x,d,m,h,T,w,b,P)}}else r=A}return Xs(this,n,t,r)}intersectsBox(n,t){return Ht.set(n.min,n.max,t),Ht.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Ht.intersectsBox(e),intersectsTriangle:e=>Ht.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},r={},l=0,i=1/0){return(this.indirect?ks:zs)(this,n,t,e,r,l,i)}closestPointToPoint(n,t={},e=0,r=1/0){return ds(this,n,t,e,r)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{v(0,new Float32Array(e),Fn),n.union(Fn)}),n}}export{Xn as A,_t as B,q as C,j as E,R as I,qn as M,Ys as N,I as O,k as R,Nn as S,Kt as T,v as a,An as b,Yn as c,Ws as d,vn as e,jn as f,Kn as g,Ks as h,Hs as i,wn as j,Js as k,N as l};
